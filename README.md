# Laravel API Application

This is a Laravel API application designed to replicate part of the WeRoad(aje) API app. There are different API endpoints to create, update and retrieve travels or tours. Some of them are public, some private, as per assignment.

## Table of Contents

1. [Introduction](#introduction)
2. [Features](#features)
3. [Installation](#installation)
4. [Usage](#usage)
5. [API Endpoints](#api-endpoints)
6. [Authentication](#authentication)
7. [Testing](#testing)
8. [Insights](#insights)
9. [Special Thanks](#special-thanks)

## Introduction

The DB structure is based on the assignment instructions. 

## Features

1. A private (admin) endpoint to create new travels;
2. A private (admin) endpoint to create new tours for a travel;
3. A private (editor) endpoint to update a travel;
4. A public (no auth) endpoint to get a list of paginated tours by the travel `slug` (e.g. all the tours of the travel `foo-bar`). Users can filter (search) the results by `priceFrom`, `priceTo`, `dateFrom` (from that `startingDate`) and `dateTo` (until that `startingDate`). User can sort the list by `price` asc and desc. They will **always** be sorted, after every additional user-provided filter, by `startingDate` asc.

## Installation

To install and run this application locally, follow these steps:

1. Clone this repository to your local machine.
2. Install Composer dependencies by running `composer install`.
3. Configure your environment variables by creating a `.env` file. You can use the `.env.example` file as a template.
4. Generate an application key by running `php artisan key:generate`.
5. Migrate the database schema by running `php artisan migrate`. (I'm using MAMP to set up a local server environment but you can use whatever you like)
6. Seed the database by running `php artisan db:seed`
7. Run `php artisan serve`


## Usage

Once you have done all the steps you are ready to go. I'm using Postman to test the API endpoints described in this document. However, feel free to use any API testing tool of your choice.
It is possible to retrieve all the routes by running `php artisan route:list --path=api`. The path will retrieve all the API routes, leaving aside the others.

## API Endpoints

1. Endpoints that requires authentication but no specific role:

- **POST** `/api/token`: Create a new token AKA Login.
- **DELETE** `/api/token`: Delete a token AKA Logout.

2. Only ADMIN endpoints:

- **POST** `/api/travels`: Create a new travel.
- **DELETE** `/api/travels/{travel}`: (Soft)Delete a specific travel.
- **POST** `/api/travels/{slug}/tours`: Create a new tour within a specific travel. 
- **POST** `/api/tours`: Create a new tour.

3. Only EDITOR|ADMIN endpoints:

- **GET|HEAD** `/api/travels`: Retrieve a list of travels.
- **GET|HEAD** `/api/travels/{travel}`: Retrieve a specific travel.
- **PUT|PATCH** `/api/travels/{travel}`: Update a specific travel.
- **GET|HEAD** `/api/travels/{slug}/tours/{tour}`: Retrieve a specific tour within a specific travel.
- **GET|HEAD** `/api/tours/{tour}`: Retrieve a specific tour.

4. Public endpoints:

- **GET|HEAD** `/api/tours`: Retrieve a list of tours.
- **GET|HEAD** `/api/travels/{slug}/tours`: Retrieve a list of tours within a specific travel.

## Authentication

I used Laravel Sanctum. The App is authenticating the User with Bearer Tokens generated by Laravel, with "abilities", determining what a User can do, based on the role.
A registered User has only one role (admin|editor|subscriber), whenever the user asks for a token, it will be generated saving the user role abilities.

Here the steps:
1. Make a POST request to `/api/token` to get a token, including a JSON object with "email" and "password"(take a look at UserSeeder for credentials). The App will answer with a "logged in as ..." message, including the Bearer Token.
2. Save it in the header as "Authorization"->"Bearer Token"
3. Have fun testing the API endpoints!

## Testing

Tests were made using PHPunit and they covers the required features.

1. **Test for Creating New Travels (Admin Endpoint)**:
   - Test that an authenticated admin user can successfully create a new travel.
   - Test that a non-admin user cannot access the endpoint to create a new travel.
   - Test that all required fields are validated and errors are returned for missing or invalid data.

2. **Test for Creating New Tours for a Travel (Admin Endpoint)**:
   - Test that an authenticated admin user can successfully create a new tour for an existing travel.
   - Test that a non-admin user cannot access the endpoint to create a new tour.
   - Test that the tour is correctly associated with the specified travel.
   - Test that all required fields are validated and errors are returned for missing or invalid data.

3. **Test for Updating a Travel (Editor|Admin Endpoint)**:
   - Test that an authenticated editor user can successfully update an existing travel.
   - Test that a non-editor user cannot access the endpoint to update a travel.

4. **Test for Retrieving Paginated Tours by Travel Slug (Public Endpoint)**:
   - Test that a user can retrieve a list of paginated tours by providing the travel slug.
   - Test that the list is sorted by `startingDate` in ascending order by default.
   - Test that the list can be sorted by `price` in ascending and descending order.
   - Test that the list can be filtered by `priceFrom`, `priceTo`, `dateFrom`, and `dateTo`, and that only tours within the specified price and date range are returned.

All the tests can be run using

```bash
php artisan test
```

## Insights

1-to-1 relationship between Travel and Mood instead of many-to-many as the mood set is always the same and is never filled partially.

Tours name are unique, so to have unique keys to send to frontEnd for dynamic generation (see more below in the response data).

In public routes Resources were used to manipulate keys, so to hide some informations and the DB structure. Uuids won't be delivered in the endpoint but travel "slug" and tour "name" can be used in requests to get all the data without issues.

## Special Thanks

Thank you AI because you're so good at helping me coding and writing documentation <3.
Thank you, WeRoad, because I enjoyed it, **really** (don't mind the blood on my head and on the keyboard, it is part of the fun.)